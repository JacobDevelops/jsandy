# JSandy MCP Server - Implementation Workflow

> Generated from [ARCHITECTURE.md](./ARCHITECTURE.md) and [REQUIREMENTS.md](./REQUIREMENTS.md).
> Execute with `/sc:implement` phase by phase.

---

## Execution Strategy

**7 phases, strictly sequential.** Phase 1 is a go/no-go gate -- if the spike fails, the entire approach needs revisiting before continuing. Phases 2-4 can have internal parallelism. Phases 5-7 are sequential finalization.

Each task has a **checkpoint** that must pass before the next task begins.

---

## Phase 1: Spike -- Validate WASM Feasibility

> **Goal**: Prove that mcp-go + syumai/workers compiles to WASM, fits under 10MB, and handles MCP requests through Cloudflare Workers.
> **Gate**: If this phase fails, STOP and reassess (TinyGo, custom MCP impl, or different platform).

### Task 1.1: Scaffold Go module and Worker project

Create the bare project structure with Go module, package.json, wrangler.toml, and Makefile.

**Files to create:**
- `apps/mcp/go.mod` -- Module declaration + dependencies
- `apps/mcp/go.sum` -- (generated by `go mod tidy`)
- `apps/mcp/package.json` -- Build scripts + wrangler dep
- `apps/mcp/wrangler.toml` -- Workers config
- `apps/mcp/Makefile` -- Build/test/deploy helpers
- `apps/mcp/.gitignore` -- Ignore build/ directory

**Actions:**
1. Create `apps/mcp/go.mod` with module path and Go 1.24
2. Create `apps/mcp/package.json` with build, dev, deploy scripts
3. Create `apps/mcp/wrangler.toml` with Worker config
4. Create `apps/mcp/Makefile` with build, test, check-size, deploy targets
5. Create `apps/mcp/.gitignore` with `build/` and Go artifacts
6. Run `cd apps/mcp && go mod tidy` to resolve dependencies

**Checkpoint:** `go.mod` and `go.sum` exist with mcp-go and syumai/workers resolved.

---

### Task 1.2: Write minimal spike main.go

Create a "hello world" MCP server that registers one tool and serves via syumai/workers.

**File to create:**
- `apps/mcp/main.go` -- Entry point with build tag, one tool, health endpoint

**Actions:**
1. Write `main.go` with `//go:build js && wasm` tag
2. Create MCPServer with one `hello` tool
3. Create StreamableHTTPServer with stateless mode
4. Wire through `http.ServeMux` with `/mcp` and `/health` routes
5. Call `workers.Serve(mux)`

**Checkpoint:** File compiles with `GOOS=js GOARCH=wasm go build` (syntax check only at this stage).

---

### Task 1.3: Build WASM binary and measure size

Compile the spike to WASM and verify it fits within Cloudflare's 10MB limit.

**Actions:**
1. Run `go run github.com/syumai/workers/cmd/workers-assets-gen@latest -mode=go` to generate JS bridge files
2. Run `GOOS=js GOARCH=wasm go build -ldflags="-s -w" -o ./build/app.wasm .`
3. Check file size: `ls -lh ./build/app.wasm`
4. Record exact size in bytes

**Decision gate:**
- **< 8MB**: Proceed with standard Go. Comfortable headroom.
- **8-10MB**: Proceed but monitor. Add `-trimpath` flag. Consider TinyGo if docs push it over.
- **> 10MB**: STOP. Evaluate options:
  - A) TinyGo compiler (may not support all mcp-go deps)
  - B) Strip mcp-go to minimal subset
  - C) Custom minimal MCP protocol impl in Go
  - D) Switch to Cloudflare Containers
  - E) Rewrite in TypeScript with Cloudflare Agents SDK

**Checkpoint:** Binary size measured and documented. Go/no-go decision made.

---

### Task 1.4: Test local Worker with wrangler dev

Run the Worker locally and verify MCP handshake works.

**Actions:**
1. Run `npx wrangler dev` from `apps/mcp/`
2. Send MCP initialize request via curl:
   ```
   curl -X POST http://localhost:8787/mcp \
     -H "Content-Type: application/json" \
     -H "Accept: application/json, text/event-stream" \
     -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}'
   ```
3. Verify response contains server info and tool capabilities
4. Send `tools/list` request and verify `hello` tool appears
5. Send `tools/call` for `hello` tool and verify response
6. Test `/health` endpoint returns `{"status":"ok"}`

**Checkpoint:** All 4 MCP operations succeed locally. MCP handshake, tool listing, tool calling, and health check all work.

---

### Task 1.5: Deploy spike to Cloudflare Workers

Deploy the minimal spike and verify it works at the actual URL.

**Actions:**
1. Run `npx wrangler deploy` from `apps/mcp/`
2. Verify deployment succeeds
3. Test health endpoint: `curl https://<workers-url>/health`
4. Test MCP initialize via curl against deployed URL
5. Test tool call against deployed URL

**Checkpoint:** Spike is live on Cloudflare Workers and MCP protocol works end-to-end over the internet.

> **Phase 1 complete.** All technical risks validated. Proceed to Phase 2.

---

## Phase 2: Foundation -- Internal Package Structure

> **Goal**: Build the internal package skeleton, knowledge base embed system, and template engine. No tool handlers yet -- just the infrastructure they depend on.

### Task 2.1: Create internal package structure

Scaffold all internal package directories and empty files.

**Directories to create:**
```
apps/mcp/internal/
├── server/
├── tools/
│   ├── codegen/
│   ├── validate/
│   ├── lookup/
│   └── analysis/
├── kb/
│   └── docs/
│       ├── api/
│       ├── guides/
│       ├── patterns/
│       └── exports/
└── templates/
```

**Actions:**
1. Create all directories
2. Create placeholder `doc.go` files in each package for Go tooling compatibility
3. Remove `//go:build js && wasm` tag from `main.go` -- internal packages must compile on all platforms for testing. The build tag only applies to the entry point's `workers.Serve()` call.

**Checkpoint:** `go vet ./internal/...` passes with no errors.

---

### Task 2.2: Implement server factory

Extract the MCPServer creation from `main.go` into `internal/server/server.go`.

**File to create:**
- `apps/mcp/internal/server/server.go`

**Implementation:**
- `NewMCPServer()` function returning `*mcpserver.MCPServer`
- `NewHandler()` function returning `http.Handler` (StreamableHTTPServer)
- Constants: `ServerName`, `ServerVersion`, `RPCVersion`
- Server instructions string
- Stateless mode, recovery, tool capabilities

**Checkpoint:** `main.go` imports and calls `server.NewHandler()`. Compiles successfully.

---

### Task 2.3: Implement template engine

Build the `internal/templates/` package with all Render functions and supporting utilities.

**Files to create:**
- `apps/mcp/internal/templates/procedure.go` -- `RenderProcedure`, `RenderWSProcedure`
- `apps/mcp/internal/templates/router.go` -- `RenderRouter`, `RenderMergeRouters`
- `apps/mcp/internal/templates/middleware.go` -- `RenderMiddleware`
- `apps/mcp/internal/templates/client.go` -- `RenderClient`
- `apps/mcp/internal/templates/adapter.go` -- `RenderPubSubAdapter`
- `apps/mcp/internal/templates/nextjs.go` -- `RenderNextJSRoute`
- `apps/mcp/internal/templates/util.go` -- Shared helpers: `writeZodFields`, `indent`, `camelToTitle`

**Implementation details:**
- All renderers use `strings.Builder` + `fmt.Fprintf` (no `text/template`)
- All generated code uses Zod v4 syntax exclusively
- All imports use `@jsandy/rpc` or `@jsandy/rpc/client`
- All generated code uses `c.superjson()` for responses
- All generated code uses named exports + ES modules
- `writeZodFields` parses human-readable field descriptions into Zod v4 field definitions

**Checkpoint:** Each Render function produces valid-looking TypeScript when called with test params. Visual inspection of output.

---

### Task 2.4: Implement validation rules

Build the `internal/tools/validate/rules.go` module with all regex-based validation patterns.

**Files to create:**
- `apps/mcp/internal/tools/validate/rules.go` -- Issue type, all compiled patterns, check functions

**Implementation:**
- `Issue` struct with Severity, Message, Line, Fix
- `zodV3Patterns` -- 11 Zod v3 anti-pattern regexes
- `procedurePatterns` -- 3 builder chain order regexes
- `importPatterns` -- 3 import path regexes
- `routerPatterns` -- Router structural checks
- `middlewarePatterns` -- Middleware pattern checks
- `nextjsPatterns` -- Next.js integration checks
- Public functions: `CheckZodV4Compliance`, `CheckProcedurePatterns`, `CheckImports`, `CheckRouterStructure`, `CheckMiddlewarePattern`, `CheckNextJSIntegration`
- Input boundary constants: `MaxCodeLength`, `MaxQueryLength`, etc.

**Checkpoint:** All regex patterns compile without error. Check functions return expected issues for known-bad code strings.

---

### Task 2.5: Write core knowledge base documents

Write the hand-written markdown documentation that will be embedded in the binary. Focus on API reference and the most critical guides first.

**Files to create (API reference -- highest priority):**
- `apps/mcp/internal/kb/docs/api/jsandy.md` -- `jsandy.init()`, defaults (cors, errorHandler)
- `apps/mcp/internal/kb/docs/api/procedure.md` -- Procedure builder: `.input()`, `.output()`, `.use()`, `.query()`, `.mutation()`, `.ws()`, `.describe()`
- `apps/mcp/internal/kb/docs/api/router.md` -- `router()`, nesting, `.use()`, `.onError()`, `.config()`
- `apps/mcp/internal/kb/docs/api/client.md` -- `createClient`, `ClientConfig`, typed usage, `$url()`, `$ws()`
- `apps/mcp/internal/kb/docs/api/middleware.md` -- `middleware()`, `fromHono()`, context accumulation, `MiddlewareFunction` type
- `apps/mcp/internal/kb/docs/api/websocket.md` -- `ServerSocket`, `ClientSocket`, `IO`, events, rooms, heartbeat
- `apps/mcp/internal/kb/docs/api/adapters.md` -- `PubSubAdapter` interface, `SubscribeOptions`, `UpstashRestPubSub`, `CloudflareQueueAdapter`
- `apps/mcp/internal/kb/docs/api/schemas.md` -- `createSchema`, `createEnumSchema`
- `apps/mcp/internal/kb/docs/api/types.md` -- `InferRouterInputs`, `InferRouterOutputs`, `InferInput`, `InferOutput`, `ContextWithSuperJSON`, `RouterSchema`
- `apps/mcp/internal/kb/docs/api/openapi.md` -- OpenAPI generation, `ProcedureDescription`

**Files to create (export listings):**
- `apps/mcp/internal/kb/docs/exports/main.md` -- All `@jsandy/rpc` exports
- `apps/mcp/internal/kb/docs/exports/client.md` -- All `@jsandy/rpc/client` exports
- `apps/mcp/internal/kb/docs/exports/adapters.md` -- All `@jsandy/rpc/adapters` exports

**Checkpoint:** All markdown files exist and contain accurate API information matching the @jsandy/rpc v2.2.0 source code.

---

### Task 2.6: Write guide and pattern documents

Write the usage guides and common pattern documents.

**Files to create (guides):**
- `apps/mcp/internal/kb/docs/guides/procedures.md`
- `apps/mcp/internal/kb/docs/guides/routers.md`
- `apps/mcp/internal/kb/docs/guides/middleware.md`
- `apps/mcp/internal/kb/docs/guides/client.md`
- `apps/mcp/internal/kb/docs/guides/websocket.md`
- `apps/mcp/internal/kb/docs/guides/pubsub-adapter.md`
- `apps/mcp/internal/kb/docs/guides/nextjs.md`
- `apps/mcp/internal/kb/docs/guides/create-app.md`
- `apps/mcp/internal/kb/docs/guides/zod-v4.md`

**Files to create (patterns):**
- `apps/mcp/internal/kb/docs/patterns/auth.md`
- `apps/mcp/internal/kb/docs/patterns/crud.md`
- `apps/mcp/internal/kb/docs/patterns/file-upload.md`
- `apps/mcp/internal/kb/docs/patterns/pagination.md`
- `apps/mcp/internal/kb/docs/patterns/error-handling.md`
- `apps/mcp/internal/kb/docs/patterns/realtime-chat.md`
- `apps/mcp/internal/kb/docs/patterns/notifications.md`

**Checkpoint:** All 16 documents exist with comprehensive content. Each guide includes code examples using Zod v4 syntax.

---

### Task 2.7: Implement knowledge base embed and search index

Build the `internal/kb/` package that embeds docs and provides search.

**Files to create:**
- `apps/mcp/internal/kb/kb.go` -- `go:embed` directives, accessor functions
- `apps/mcp/internal/kb/index.go` -- `Entry` type, `buildIndex()`, `Lookup()`, `Search()`, `SearchResult`

**Implementation:**
- Embed all 4 doc directories with `//go:embed docs/api/*.md` etc.
- `GetAPIDoc(name)`, `GetGuide(name)`, `GetPattern(name)`, `GetExports(entryPoint)` accessors
- `buildIndex()` creates entries from all embedded docs with name, kind, keywords, summary
- `Lookup(name)` exact match (case-insensitive) returns entry + content
- `Search(query, maxResults)` keyword scoring with name/summary boost
- `sync.Once` lazy initialization

**Checkpoint:** `kb.Lookup("createClient")` returns the client API doc. `kb.Search("websocket rooms", 5)` returns relevant results.

---

### Task 2.8: Implement tool registry

Build the central registration module that wires all tool subpackages to the MCPServer.

**File to create:**
- `apps/mcp/internal/tools/registry.go`

**Implementation:**
- `RegisterAll(s *mcpserver.MCPServer)` calls each subpackage's `Register(s)` function
- At this point, subpackages will have stub `Register` functions

**Checkpoint:** `server.NewMCPServer()` + `tools.RegisterAll(s)` compiles. Server starts with 0 tools (stubs).

> **Phase 2 complete.** All infrastructure is built. Template engine, validation rules, knowledge base, and search all work independently.

---

## Phase 3: Tool Handlers -- Code Generation

> **Goal**: Implement all 8 code generation tools and register them.

### Task 3.1: Implement create_procedure and create_ws_procedure

**File to create:**
- `apps/mcp/internal/tools/codegen/procedure.go`

**Tools:**
- `create_procedure` -- Query/mutation procedure generation
- `create_ws_procedure` -- WebSocket procedure with incoming/outgoing events

**Implementation:**
- Tool definitions with all parameters (name, type, inputSchema, outputSchema, middleware, description)
- Handlers extract params and delegate to `templates.RenderProcedure` / `templates.RenderWSProcedure`
- `registerProcedureTools(s)` exported for registry

**Checkpoint:** Calling `create_procedure` with `{name: "getUser", type: "query", inputSchema: "id: string"}` returns valid TypeScript code with Zod v4 imports.

---

### Task 3.2: Implement create_router and merge_routers

**File to create:**
- `apps/mcp/internal/tools/codegen/router.go`

**Tools:**
- `create_router` -- Router definition with procedure registrations
- `merge_routers` -- mergeRouters configuration

**Checkpoint:** Generated router code includes correct `router()` call with procedure entries.

---

### Task 3.3: Implement create_middleware

**File to create:**
- `apps/mcp/internal/tools/codegen/middleware.go`

**Tool:** `create_middleware` -- Middleware with context accumulation

**Checkpoint:** Generated middleware includes `next({ ...contextFields })` pattern.

---

### Task 3.4: Implement create_client

**File to create:**
- `apps/mcp/internal/tools/codegen/client.go`

**Tool:** `create_client` -- createClient setup and typed usage

**Checkpoint:** Generated client code imports from `@jsandy/rpc/client` and includes type reference.

---

### Task 3.5: Implement create_pubsub_adapter

**File to create:**
- `apps/mcp/internal/tools/codegen/adapter.go`

**Tool:** `create_pubsub_adapter` -- Custom PubSubAdapter implementation

**Checkpoint:** Generated adapter implements `PubSubAdapter` interface with `publish` and `subscribe` methods.

---

### Task 3.6: Implement setup_nextjs_route

**File to create:**
- `apps/mcp/internal/tools/codegen/nextjs.go`

**Tool:** `setup_nextjs_route` -- Next.js App Router route handler

**Checkpoint:** Generated route handler includes proper Next.js exports (GET, POST) and jsandy/rpc integration.

---

### Task 3.7: Implement codegen shared utilities and Register function

**Files to create:**
- `apps/mcp/internal/tools/codegen/codegen.go` -- Shared utilities
- Update all codegen files to wire their `register*Tools` into a single `Register(s)` function

**Checkpoint:** `codegen.Register(s)` registers all 8 tools. `tools/list` shows 8 codegen tools.

---

> **Phase 3 complete.** All 8 code generation tools are functional.

---

## Phase 4: Tool Handlers -- Validation, Lookup, Analysis

> **Goal**: Implement the remaining 10 tools across 3 categories.

### Task 4.1: Implement validation tool handlers

**Files to create:**
- `apps/mcp/internal/tools/validate/procedure.go` -- `validate_procedure`
- `apps/mcp/internal/tools/validate/router.go` -- `validate_router`
- `apps/mcp/internal/tools/validate/middleware.go` -- `validate_middleware`
- `apps/mcp/internal/tools/validate/nextjs.go` -- `validate_nextjs_integration`
- `apps/mcp/internal/tools/validate/zod.go` -- `check_zod_v4_compliance`
- `apps/mcp/internal/tools/validate/validate.go` -- `Register(s)` function

**Implementation:**
- Each handler extracts `code` param, runs relevant check functions from `rules.go`
- Aggregates issues, sorts by severity
- Returns JSON-encoded issue array via `mcp.NewToolResultText`
- Input bounded by `MaxCodeLength`

**Checkpoint:** `validate_procedure` with code containing `.nativeEnum()` returns Zod v3 error with fix suggestion.

---

### Task 4.2: Implement lookup tool handlers

**Files to create:**
- `apps/mcp/internal/tools/lookup/api.go` -- `lookup_api`
- `apps/mcp/internal/tools/lookup/search.go` -- `search_docs`
- `apps/mcp/internal/tools/lookup/exports.go` -- `list_exports`
- `apps/mcp/internal/tools/lookup/examples.go` -- `get_examples`
- `apps/mcp/internal/tools/lookup/lookup.go` -- `Register(s)` function

**Implementation:**
- `lookup_api`: Uses `kb.Lookup(name)`. On miss, calls `kb.Search(name, 5)` for "did you mean" suggestions
- `search_docs`: Uses `kb.Search(query, 10)`. Returns formatted list of results with summaries
- `list_exports`: Uses `kb.GetExports(entryPoint)`. Returns the export listing document
- `get_examples`: Uses `kb.GetPattern(pattern)` or `kb.Search(pattern, 3)`. Returns example code

**Checkpoint:** `lookup_api("createClient")` returns the full API doc. `search_docs("websocket")` returns ranked results.

---

### Task 4.3: Implement analysis tool handlers

**Files to create:**
- `apps/mcp/internal/tools/analysis/code.go` -- `analyze_code`
- `apps/mcp/internal/tools/analysis/project.go` -- `analyze_project_structure`
- `apps/mcp/internal/tools/analysis/improve.go` -- `suggest_improvements`
- `apps/mcp/internal/tools/analysis/analysis.go` -- `Register(s)` function

**Implementation:**
- `analyze_code`: Runs all validation checks, augments with best-practice recommendations from kb
- `analyze_project_structure`: Parses JSON structure input, checks for Next.js patterns, suggests file placements, identifies missing deps
- `suggest_improvements`: Combines validation checks with improvement suggestions based on goal description
- All three accept both `code` and `structure` as string inputs (remote server, no filesystem access)

**Checkpoint:** `analyze_project_structure` with a Next.js app directory structure returns correct route handler placement suggestions.

---

### Task 4.4: Wire all tools into registry

Update `internal/tools/registry.go` to call all 4 subpackage `Register` functions.

**Checkpoint:** Server starts with all 18 tools registered. `tools/list` returns 18 tools.

---

> **Phase 4 complete.** All 18 tools are implemented and registered.

---

## Phase 5: Testing

> **Goal**: Comprehensive test coverage for all components.

### Task 5.1: Write template tests

**File to create:**
- `apps/mcp/internal/templates/templates_test.go`

**Tests:**
- Each Render function with various param combinations
- Verify output contains correct imports (`@jsandy/rpc`, `zod`)
- Verify Zod v4 syntax (no v3 patterns in output)
- Verify `c.superjson()` usage
- Verify named exports
- Verify correct handler method (query vs mutation)
- Verify WebSocket procedure has incoming/outgoing schemas
- Verify PubSubAdapter has publish/subscribe methods

**Checkpoint:** `go test ./internal/templates/...` passes.

---

### Task 5.2: Write validation tests

**File to create:**
- `apps/mcp/internal/tools/validate/validate_test.go`

**Tests:**
- Each Zod v3 anti-pattern detected correctly
- Clean Zod v4 code passes with no issues
- Incorrect procedure builder chain detected
- Bad import paths detected
- Missing patterns detected
- Input boundary enforcement (code > MaxCodeLength rejected)
- Issue severity levels correct

**Checkpoint:** `go test ./internal/tools/validate/...` passes.

---

### Task 5.3: Write knowledge base tests

**File to create:**
- `apps/mcp/internal/kb/kb_test.go`

**Tests:**
- All embedded docs load successfully
- `Lookup` finds each API entry by exact name
- `Lookup` is case-insensitive
- `Lookup` returns false for unknown names
- `Search` returns relevant results for various queries
- `Search` respects maxResults limit
- `GetAPIDoc`, `GetGuide`, `GetPattern`, `GetExports` all return content
- Search scoring: name matches rank higher than keyword matches

**Checkpoint:** `go test ./internal/kb/...` passes.

---

### Task 5.4: Write integration tests

**File to create:**
- `apps/mcp/internal/server/server_test.go`

**Tests:**
- `NewMCPServer()` creates server with correct name and version
- All 18 tools are registered
- Server instructions contain version info
- Tool handler dispatch works for each tool category
- Invalid tool parameters return proper MCP errors

**Checkpoint:** `go test ./internal/...` -- all tests pass.

---

### Task 5.5: WASM build verification

Rebuild the full binary with all code and verify size constraint.

**Actions:**
1. Run `make build` from `apps/mcp/`
2. Run `make check-size` to verify < 10MB
3. Record final binary size
4. If > 10MB: apply mitigations per ARCHITECTURE.md section 6.6

**Checkpoint:** Binary size < 10MB. Full project builds to WASM without errors.

---

> **Phase 5 complete.** All tests pass and binary fits within size constraints.

---

## Phase 6: Local Integration Testing

> **Goal**: Verify the complete MCP server works locally with real MCP clients.

### Task 6.1: Test full MCP protocol locally

**Actions:**
1. Run `make dev` (starts wrangler dev)
2. Test full protocol flow via curl:
   - `initialize` → verify capabilities + server info
   - `initialized` notification
   - `tools/list` → verify all 18 tools
   - `tools/call` for each tool category (one from each)
   - Health endpoint
3. Test error cases:
   - Unknown tool name → proper error
   - Missing required parameter → proper error
   - Code exceeding MaxCodeLength → proper error

**Checkpoint:** All MCP operations succeed. Error cases return proper JSON-RPC errors.

---

### Task 6.2: Test with Claude Code (local)

**Actions:**
1. Configure Claude Code to connect to `http://localhost:8787/mcp`
2. Verify Claude discovers all 18 tools
3. Test a conversation where Claude uses the tools:
   - Ask Claude to create a procedure
   - Ask Claude to validate some code
   - Ask Claude to look up an API
4. Verify generated code quality

**Checkpoint:** Claude Code connects and uses tools correctly in a real conversation.

---

> **Phase 6 complete.** Server is verified working locally with real clients.

---

## Phase 7: Deployment

> **Goal**: Deploy to production at `mcp.jsandy.com` and verify.

### Task 7.1: Deploy to Cloudflare Workers

**Actions:**
1. Run `make deploy` from `apps/mcp/`
2. Verify deployment succeeds
3. Note the deployed Workers URL

**Checkpoint:** Wrangler deploy succeeds.

---

### Task 7.2: Configure custom domain

**Actions:**
1. Configure `mcp.jsandy.com` DNS to point to the Worker
   - If using Cloudflare DNS: add Workers Custom Domain in wrangler.toml or dashboard
   - If using external DNS: CNAME to `jsandy-mcp.<account>.workers.dev`
2. Verify HTTPS works at `https://mcp.jsandy.com/health`
3. Verify MCP endpoint at `https://mcp.jsandy.com/mcp`

**Checkpoint:** `curl https://mcp.jsandy.com/health` returns `{"status":"ok"}`.

---

### Task 7.3: Test production MCP server

**Actions:**
1. Run full MCP protocol test against `https://mcp.jsandy.com/mcp`
2. Configure Claude Code to connect to the production URL
3. Run a test conversation exercising all tool categories
4. Verify response times < 500ms for tool calls

**Checkpoint:** Production MCP server works end-to-end with real MCP clients.

---

### Task 7.4: Set up CI/CD pipeline

**File to create:**
- `.github/workflows/mcp.yml`

**Pipeline steps:**
1. Trigger on push to `main` when `apps/mcp/**` changes
2. Install Go 1.24+
3. Run `go test ./internal/...`
4. Build WASM binary
5. Check binary size < 10MB
6. Deploy to Cloudflare Workers (using CLOUDFLARE_API_TOKEN secret)

**Checkpoint:** Push a change to `apps/mcp/` and verify CI runs and deploys automatically.

---

> **Phase 7 complete.** Server is live at `https://mcp.jsandy.com`, CI/CD is configured, custom domain works.

---

## Task Dependency Graph

```
Phase 1 (Spike - GATE)
  1.1 Scaffold ──▶ 1.2 main.go ──▶ 1.3 Build ──▶ 1.4 Local test ──▶ 1.5 Deploy
                                        │
                                   GO/NO-GO
                                        │
Phase 2 (Foundation)                    ▼
  2.1 Package structure
    │
    ├──▶ 2.2 Server factory
    │
    ├──▶ 2.3 Template engine ─────────────────────────────────┐
    │                                                         │
    ├──▶ 2.4 Validation rules ─────────────────────────────┐  │
    │                                                      │  │
    ├──▶ 2.5 API reference docs ──┐                        │  │
    │                             ├──▶ 2.7 KB embed+search │  │
    ├──▶ 2.6 Guide/pattern docs ──┘           │            │  │
    │                                         │            │  │
    └──▶ 2.8 Tool registry (stubs) ◀──────────┘            │  │
                                                           │  │
Phase 3 (Codegen Tools)                                    │  │
  3.1 Procedures ──┐                                       │  │
  3.2 Routers ─────┤                                       │  │
  3.3 Middleware ───┤ (depends on templates: 2.3)───────────│──┘
  3.4 Client ──────┤                                       │
  3.5 Adapter ─────┤                                       │
  3.6 Next.js ─────┤                                       │
  3.7 Wire+Register┘                                       │
                                                           │
Phase 4 (Remaining Tools)                                  │
  4.1 Validation handlers (depends on rules: 2.4)─────────┘
  4.2 Lookup handlers (depends on KB: 2.7)
  4.3 Analysis handlers (depends on both validation + KB)
  4.4 Wire all into registry
       │
Phase 5 (Testing)
  5.1 Template tests
  5.2 Validation tests    (all can run in parallel)
  5.3 KB tests
  5.4 Integration tests
  5.5 WASM build verify
       │
Phase 6 (Local Integration)
  6.1 Full protocol test ──▶ 6.2 Claude Code test
       │
Phase 7 (Deployment)
  7.1 Deploy ──▶ 7.2 Domain ──▶ 7.3 Production test ──▶ 7.4 CI/CD
```

---

## Summary

| Phase | Tasks | Description |
|-------|-------|-------------|
| **1** | 5 | Spike: WASM feasibility gate |
| **2** | 8 | Foundation: packages, templates, KB, validation rules, search |
| **3** | 7 | Code generation tools (8 tools) |
| **4** | 4 | Validation, lookup, analysis tools (10 tools) |
| **5** | 5 | Testing: unit, integration, binary size |
| **6** | 2 | Local integration with MCP clients |
| **7** | 4 | Deploy, custom domain, CI/CD |
| **Total** | **35 tasks** | |

### Critical Path

```
1.1 → 1.2 → 1.3 (GO/NO-GO) → 2.1 → 2.3/2.5 → 2.7 → 3.1 → 4.4 → 5.4 → 6.1 → 7.1 → 7.3
```

The critical path runs through the spike gate, then through templates and knowledge base (both are dependencies for tool handlers), then through integration testing and deployment.
